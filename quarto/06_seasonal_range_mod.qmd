---
title: "Home Range Modelling"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
execute: 
  warning: false
  error: false
---

```{r}
#| label: load-packages
#| include: false

library(sf)
library(here)
library(terra)
library(tidyverse)
```

```{r}
#| label: load-data
#| echo: false

musk_collar_filt <- readRDS(here("data/processed/musk_collar_filt.rds"))
musk_seascont <- readRDS(here("output/musk_seascont.rds"))
musk_seascontwint <- readRDS(here("output/musk_seascontwint.rds"))
```

Now we will look to model variables that are likely to influence the size of home ranges. Since we have few observations per season (sample size 12 - 15), we want 1 - 2 explantory variables per season model. Average snow cover during the winter and calving seasons may impact home range size, with individuals being restricted from moving large distances. During the summer, the percent of landcover suitable for foraging or number of foraging patches may impact the size of home ranges with larger home ranges occurring when individuals need to travel more often or further to get to foraging areas. Other barriers to movement may also affect home range size, including ridges and lakes.

# Home Range Size Models

First we will examine differences in the home range over time for each muskoxen.

Let's start by calculating average snow depth within each winter and calving home range. To be consistent across years and individuals, we will estimate mean snow depth across the same period ranging from the start November to the end of March for winter and March for calving. These periods roughly correspond to the shortest seasons across the data and include the most extreme snow depths.

## Winter Season Model

We'll start by estimating average snow depth for winter and running model with muskox ID as a random effect. For this model, we will use the winter home range estimates that were limited to the months January-March to control for season length and to focus on the periods of highest snow depth.

```{r}
#| label: musk_wint
#| dependson: "load-data"

sm_crop <- terra::rast(here("data/processed/sm_crop.nc"), 
                       drivers="NETCDF")
daterange <- seq( as.Date("2007-01-01"), as.Date("2012-12-31"), by="+1 day")

snow_wint_func <- function(id, range){
  year <- musk_seascontwint %>%
    filter(range_id == !!id, range == !!range) %>%
    pull(year_min)
  zones <- rasterize(musk_seascontwint %>%
                           filter(range_id == !!id, range == !!range) %>%
                      sf::st_transform(terra::crs(sm_crop)) %>%
                        vect(),
                    sm_crop, touches = TRUE)
  rowids <- which(month(daterange)>=11&year(daterange)==year|
          month(daterange)<=3&year(daterange)==(year+1))
  zonal(sm_crop[[rowids]], zones, "mean", wide = FALSE) %>%
    mutate(date = daterange[rowids], 
           range_id = !!id,
           range = !!range) %>%
    select(-layer, -zone)
}

musk_wint_home <- musk_seascontwint %>%
  filter(season == "Winter",
         range == "home",
         seas_length > 115
         ) %>%
  pull(range_id) %>%
  map(function(.x){snow_wint_func(.x, "home")}) %>%
  list_rbind() 
musk_wint_core <- musk_seascontwint %>%
  filter(season == "Winter",
         range == "core",
         seas_length > 115
         ) %>%
  pull(range_id) %>%
  map(function(.x){snow_wint_func(.x, "core")}) %>%
  list_rbind() 
musk_wint <- bind_rows(musk_wint_home, musk_wint_core)
```

```{r}
#| label: wint_mod
#| dependson: "musk_wint"

musk_wint_sum <- musk_wint %>%
  group_by(range_id, range) %>%
  summarise(snow_depth = mean(value)) %>%
  left_join(musk_seascontwint %>%
              select(range_id, range, year_min, seas_length, area, Id_Number))
saveRDS(musk_wint_sum, here("output/musk_wint_sum.rds"))

musk_wint_sum %>%
  ggplot(aes(x = snow_depth, y = area, colour = Id_Number)) +
  geom_point(size = 3) +
  scale_y_log10() +
  facet_wrap(~range, scales = "free")

wint_home_mod <- nlme::lme(log(area)~scale(snow_depth), random=~1|Id_Number,
                 data = musk_wint_sum %>% filter(range == "home"))
summary(wint_home_mod)
MuMIn::r.squaredGLMM(wint_home_mod)

wint_core_mod <- nlme::lme(log(area)~scale(snow_depth), random=~1|Id_Number, 
                 data = musk_wint_sum %>% filter(range == "core"))
summary(wint_core_mod)
MuMIn::r.squaredGLMM(wint_core_mod)


# set.seed(5)
# wint_home_brms <- brms::brm(log(area)~scale(snow_depth) + (1|Id_Number), 
#                  data = musk_wint_sum %>% filter(range == "home"),
#                  family = "gaussian",
#                  chains = 3,
#                  cores = 3,
#                  iter = 4000,
#                  control = list(adapt_delta = 0.99))
# summary(wint_home_brms)
# set.seed(5)
# wint_core_brms <- brms::brm(log(area)~scale(snow_depth) + (1|Id_Number), 
#                  data = musk_wint_sum %>% filter(range == "core"),
#                  family = "gaussian",
#                  chains = 3,
#                  cores = 3,
#                  iter = 4000,
#                  control = list(adapt_delta = 0.99))
# summary(wint_core_brms)

```

Clearly, there is a negative relationship between snow depth and winter range size: as snow depth increases, the size of winter home ranges tends to decrease. In addition, each muskox with multiple years of data had a smaller winter home range in the year with deeper snow.

It's also worth noting that the three instances with the deepest snow all occurred in 2010, but all three home ranges occurred in spatially distinct areas. There could be another weather variable correlated with years that is responsible for the relationship, but snow depth seems the most plausible given previous research. Also, if we include the three winter home ranges that were only calculated for part of the season (due to starting or ending mid winter), they fit the trend as 2007 and 2011 were also years with deeper snow.

## Calving Season Model

Next we will look at the same relationship for the calving seasons:

```{r}
#| label: musk_calv
#| dependson: "load-data"

sm_crop <- terra::rast(here("data/processed/sm_crop.nc"), 
                       drivers="NETCDF")
daterange <- seq( as.Date("2007-01-01"), as.Date("2012-12-31"), by="+1 day")
snow_calv_func <- function(id, range){
  year <- musk_seascont %>%
    filter(range_id == !!id, range == !!range) %>%
    pull(year_min)
  zones <- rasterize(musk_seascont %>%
                           filter(range_id == !!id, range == !!range) %>%
                      sf::st_transform(terra::crs(sm_crop)) %>%
                        terra::vect(),
                    sm_crop, touches = TRUE)
  rowids <- which(month(daterange)==4&year(daterange)==year)
  zonal(sm_crop[[rowids]], zones, "mean", wide = FALSE) %>%
    mutate(date = daterange[rowids], 
           range_id = !!id,
           range = !!range) %>%
    select(-layer, -zone)
}

musk_calv_home <- musk_seascont %>%
  filter(season == "Calving",
         range == "home"
         ) %>%
  pull(range_id) %>%
  map(function(.x){snow_calv_func(.x, "home")}) %>%
  list_rbind() 
musk_calv_core <- musk_seascont %>%
  filter(season == "Calving",
         range == "core"
         ) %>%
  pull(range_id) %>%
  map(function(.x){snow_calv_func(.x, "core")}) %>%
  list_rbind() 
musk_calv <- bind_rows(musk_calv_home, musk_calv_core)
```

```{r}
#| label: calv_mod
#| dependson: "musk_calv"

musk_calv_sum <- musk_calv %>%
  group_by(range_id, range) %>%
  summarise(snow_depth = mean(value)) %>%
  left_join(musk_seascont %>%
              select(range_id, range, year_min, seas_length, area, Id_Number)) 

musk_calv_sum %>%
  ggplot(aes(x = snow_depth, y = log(area), colour = Id_Number)) +
  geom_point(size = 3) +
  facet_wrap(~range, scales = "free")

calv_home_mod <- lme4::lmer(log(area)~scale(snow_depth) + (1|Id_Number), 
                 data = musk_calv_sum %>% filter(range == "home"))
summary(calv_home_mod)
MuMIn::r.squaredGLMM(calv_home_mod)

calv_core_mod <- lme4::lmer(log(area)~scale(snow_depth)+(1|Id_Number), 
                 data = musk_calv_sum %>% filter(range == "core"))
summary(calv_core_mod)

```

There is still a negative relationship present between snow depth and calving home range size, but it is no longer significant. Given that we do not actually know which females had calves every year, the presence/absence of calves could have a large impact on the area traversed during this time. For instance, we know that muskox 7010 in 2009 was not seen with a calf during any of the surveys and happens to have the largest home range size during the calving season. Similarly, muskox 7012 in 2009, which had the second largest home range, was not with a calf until May at the earliest. This means 7012 was not restricted from moving around during the deepest parts of the calving season. Removing these two points makes for a much stronger relationship; however this pattern is not universal as there were other muskoxen in 2008 and 2009 that were without calves during April and still had small home ranges. The fact that these muskoxen travel in groups needs to be taken into consideration as well because even if the collared muskoxen does not have a calf, its movements may still be restricted by the movements of the group. Most groups observed in 2008 and 2009 had at least one calf during the calving season. One exception was 7010 in 2009, which was observed to be in a group with a calf at the beginning of April but not in May.

## Summer Season Model

For the summer season, length of season and forage availability are likely to be more important for determining home range size than weather conditions (though extreme heat and bugs in the summer could impact movement as well). Like winter and calving season models, we will stick with one predictor variable to avoid issues with overfitting. In this case, we will look at the percentage of shrubland and grassland within each home range, with the hypothesis that areas with less shrubland/grassland will mean muskoxen will need to travel further to meet their energy demands and consequently have larger home ranges.

We'll start by loading the land cover data and calculating percent cover.

```{r}
#| label: musk_sum
#| dependson: "load-data"

lc_2010_crop <- terra::rast(here("data/processed/lc_2010_crop.tif"))
lc_atts <- readRDS(here("data/processed/lc_atts.rds"))
### land cover ids 8 and 10 coorespond to the land covers of interest
lcc_func <- function(id, range){
  points <- musk_seascont %>%
    filter(range_id == !!id, range == !!range) %>%
    sf::st_transform(terra::crs(lc_2010_crop))
  lc_2010_crop2 <- terra::crop(lc_2010_crop, points)
  zones <- rasterize(points %>%
                        terra::vect(),
                    lc_2010_crop2, touches = TRUE)
  ct <- crosstab(c(zones, lc_2010_crop2)) %>%
    as_tibble() %>%
    mutate(range_id = !!id,
           range = !!range)
}

musk_sum_home <- musk_seascont %>%
  filter(season == "Summer",
         range == "home") %>%
  pull(range_id) %>%
  map(function(.x){lcc_func(.x, "home")}) %>%
  list_rbind() 
musk_sum_core <- musk_seascont %>%
  filter(season == "Summer",
         range == "core") %>%
  pull(range_id) %>%
  map(function(.x){lcc_func(.x, "core")}) %>%
  list_rbind() 
musk_sum <- bind_rows(musk_sum_home, musk_sum_core)
```

```{r}
#| label: sum_mod
#| dependson: "musk_sum"

musk_sum_sum <- musk_sum %>%
  mutate(for_lc = ifelse(cover%in%c("Temperate or sub-polar shrubland",
                                    "Temperate or sub-polar grassland",
                                    "Sub-polar or polar shrubland-lichen-moss",
                                    "Sub-polar or polar grassland-lichen-moss",
                                    "Sub-polar or polar barren-lichen-moss"),1,0)) %>%
  group_by(range_id, range) %>%
  summarise(total = sum(n),
            for_tot = sum(n*for_lc),
            for_per = for_tot/total) %>%
  left_join(musk_seascont %>%
              select(range_id, range, year_min, seas_length, area, Id_Number)) 

musk_sum_sum %>%
  ggplot(aes(x = for_per, y = log(area), colour = Id_Number)) +
  geom_point(size = 3) +
  facet_wrap(~range, scales = "free")

sum_home_mod <- nlme::lme(log(area)~scale(for_per), random=~1|Id_Number, 
                 data = musk_sum_sum %>% filter(range == "home"))
summary(sum_home_mod)
sum_core_mod <- nlme::lme(log(area)~scale(for_per), random=~1|Id_Number, 
                 data = musk_sum_sum %>% filter(range == "core"))
summary(sum_core_mod)
```

A lot of the variation in home range size is explained by differences in individual muskoxen; i.e. summer home ranges are similar in size across seasons, and we already know that they share high overlap across years.

The relationship with forage percent cover is in opposition to the original hypothesis. Larger home ranges appear to be correlated with a larger percent of forage land cover, though not significant. Maybe if there is a high density of foraging areas, it makes sense to target foraging areas that haven't been visited lately so there is a maximal amount of forage. For individuals in areas with low density of foraging areas, maybe it makes more sense to not travel long distances to new foraging patches and just stay with the ones that are nearby. By this logic, we might expect the area immediately surrounding home ranges to have a low density of forage areas.

Before we compare the areas inside and outside of summer home ranges lets look to see if season length has any effect on summer season size.

```{r}
#| label: sum_length_mod
#| dependson: "load-data"

musk_seascont %>%
  filter(season == "Summer") %>%
  ggplot(aes(x = seas_length, y = log(area), colour = Id_Number)) +
  geom_point(size = 3) +
  facet_wrap(~range, scales = "free")

sum_home_length_mod <- nlme::lme(log(area)~scale(seas_length), 
                                 random=~1|Id_Number, 
                                 data = musk_seascont %>%
                                   filter(season == "Summer",
                                          range == "home"))
summary(sum_home_length_mod)
sum_core_length_mod <- nlme::lme(log(area)~scale(seas_length), 
                                 random=~1|Id_Number, 
                                 data = musk_seascont %>%
                                   filter(season == "Summer",
                                          range == "core"))
summary(sum_core_length_mod)
```

```{r}
#| label: mod_coef
#| echo: FALSE
confintz <- function(mod, seas, cont){
  conf_list <- nlme::intervals(mod) 
  conf_tidy <- broom.mixed::tidy(mod, conf.int = TRUE) %>%
    select(effect, group, term, estimate, conf.low, conf.high) %>%
    mutate(conf.low = ifelse(term == "sd_Observation",
                             conf_list$sigma["lower"],
                             conf.low),
           conf.high = ifelse(term == "sd_Observation",
                             conf_list$sigma["upper"],
                             conf.high),
           season = seas,
           contour = cont)
}
confintz2 <- function(mod, seas, cont){
  confs <- confint(mod) %>%
    as_tibble() %>%
    rename(conf.low = `2.5 %`,
           conf.high = `97.5 %`) %>%
    mutate(term = c("sd__(Intercept)", "sd__Observation",
                    "(Intercept)", "scale(snow_depth)")) 
  conf_tidy <- broom::tidy(mod) %>%
    mutate(season = seas,
           contour = cont) %>%
    left_join(confs) %>%
    select(effect, group, term, estimate, conf.low, conf.high, season, contour)
}
mod_coef <- confintz(wint_home_mod, "Winter", "95%") %>%
  bind_rows(confintz(wint_core_mod, "Winter", "50%")) %>%
  bind_rows(confintz(sum_home_length_mod, "Summer", "95%")) %>%
  bind_rows(confintz(sum_core_length_mod, "Summer", "50%")) %>%
  bind_rows(confintz2(calv_home_mod, "Calving", "95%")) %>%
  bind_rows(confintz2(calv_core_mod, "Calving", "50%"))

saveRDS(mod_coef, here("output/mod_coef.rds"))
```

There is no significant relationship. If anything, there is a slight negative trend with season length. In fact, as we observed previously, summer home ranges are fairly consistent in size within individuals despite differences in season length across years (see 7011, 7012, 7013, and 708 in graph above), meaning our previous finding of the availability of foraging patches is probably more important.

# Home Range Selection Models

Instead of comparing the home range to the adjacent landscape, let's compare the home ranges to random locations within the study area with the same shape.

Let's start by generating random points to move the centers of each home range. We'll restrict these random points to the minimum convex polygon surrounding all telemetry locations. We'll also ensure that home ranges do not overlap large water bodies by more than 10% (a similar threshold for real home ranges).

```{r}
#| label: study_area
#| dependson: "load-data"

study_area <- st_convex_hull(st_union(musk_collar_filt$geometry)) 
hr_polygons <- readRDS(here("output/akde_conts.rds")) 

hr_shift <- function(hr, Id, season, seed){
  lc_2010_crop <- terra::rast(here("data/processed/lc_2010_crop.tif"))
  if(season == "Summer"){boundary <- hr_polygons %>% 
    filter(Id_Number == Id) %>%
    st_buffer(20000)
    }else{boundary <- hr_polygons %>% filter(Id_Number == Id)}
  set.seed(seed)
  ### repeat for 10 trials until the proportion of lakes is not too high
  for (i in 1:10){
    point <- st_sample(boundary, size = 1, type = "random") %>%
      st_transform(st_crs(hr))
    diff = point - st_centroid(hr)
    poly <- (hr + diff) %>%
      st_set_crs(st_crs(hr))
    poly2 <- poly %>%
      sf::st_transform(terra::crs(lc_2010_crop))
    lc_2010_crop2 <- terra::crop(lc_2010_crop, poly2)
    zones <- rasterize(poly2 %>%
                        terra::vect(),
                    lc_2010_crop2, touches = TRUE)
    ct <- crosstab(c(zones, lc_2010_crop2)) %>%
      as_tibble() %>%
      mutate(water = ifelse(cover=="Water",1,0)) %>%
      summarise(total = sum(n),
                wat_tot = sum(n*water),
                wat_per = wat_tot/total) %>%
      pull(wat_per)
    if(ct<=0.1){
      return(poly)
    }
  }
}

musk_pseudohr <- musk_seascont %>%
  filter(range == "home") %>%
  mutate(seed = 1:n()) %>%
  rowwise() %>%
  mutate(new_geometry = hr_shift(geometry, Id_Number, season, seed))
    
```

Let's look at the proportion of forage land cover again. This time, we will use a logistic model to compare used vs available home ranges (real vs. pseudo) to see if there is a significant difference. We will use a random effect of muskox ID for the slope term, as we do not expect the intercepts to vary across individuals because they have the same proportion of success and failures

```{r}
#| label: lc_pseudo
#| dependson: "study_area"
#| echo: FALSE

lc_2010_crop <- terra::rast(here("data/processed/lc_2010_crop.tif"))
lcc_func4 <- function(id){
  poly <- musk_pseudohr %>%
    filter(range_id == !!id) %>%
    mutate(
      geometry = sf::st_transform(geometry,terra::crs(lc_2010_crop)),
      new_geometry = sf::st_transform(new_geometry,terra::crs(lc_2010_crop)))
  lc_2010_crop1 <- terra::crop(lc_2010_crop, poly$geometry)
  lc_2010_crop2 <- terra::crop(lc_2010_crop, poly$new_geometry)
  zones1 <- rasterize(poly$geometry %>%
                        terra::vect(),
                    lc_2010_crop1, touches = TRUE)
  zones2 <- rasterize(poly$new_geometry %>%
                        terra::vect(),
                    lc_2010_crop2, touches = TRUE)
  ct1 <- crosstab(c(zones1, lc_2010_crop1)) %>%
    as_tibble() %>%
    mutate(range_id = !!id,
           group = "true")
  ct2 <- crosstab(c(zones2, lc_2010_crop2)) %>%
    as_tibble() %>%
    mutate(range_id = !!id,
           group = "pseudo")
  ct <- bind_rows(ct1, ct2)
}

hr_landcover <- musk_pseudohr %>%
  pull(range_id) %>%
  map(function(.x){bind_rows(lcc_func4(.x))}) %>%
  list_rbind()
saveRDS(hr_landcover, here("output/hr_landcover.rds"))


hr_forage <- hr_landcover %>%
  mutate(forage_lc = ifelse(cover%in%c("Temperate or sub-polar shrubland",
                                       "Temperate or sub-polar grassland",
                                       "Sub-polar or polar shrubland-lichen-moss",
                                       "Sub-polar or polar grassland-lichen-moss",
                                       "Sub-polar or polar barren-lichen-moss"),1,0),
         forest_lc = ifelse(cover%in%c("Sub-polar taiga needleleaf forest",
                                       "Temperate or sub-polar needleleaf forest",
                                       "Mixed forest",
                                       "Temperate or sub-polar broadleaf deciduous forest"),1,0)) %>%
  group_by(range_id, group) %>%
  summarise(total = sum(forage_lc*n+forest_lc*n),
            for_tot = sum(n*forage_lc),
            for_per = for_tot/total) 

```

```{r}
#| label: tpi_pseudo
#| dependson: c("study_area" "musk_snow")
#| echo: FALSE

mrdtm_crop <- terra::rast(here("data/processed/mrdtm_crop.tif"))
mrdtm_agg <- terra::aggregate(mrdtm_crop, fact = 5)
tpi_crop <- spatialEco::tpi(mrdtm_agg, scale = 3000, win = "circle")

tpi_func <- function(id, layer){
  poly <- musk_pseudohr %>%
    filter(range_id == !!id) %>%
    mutate(
      geometry = sf::st_transform(geometry,terra::crs(layer)),
      new_geometry = sf::st_transform(new_geometry,terra::crs(layer)))
  tpi_crop1 <- terra::crop(layer, poly$geometry)
  tpi_crop2 <- terra::crop(layer, poly$new_geometry)
  zones1 <- rasterize(poly$geometry %>%
                        terra::vect(),
                    tpi_crop1, touches = TRUE)
  zones2 <- rasterize(poly$new_geometry %>%
                        terra::vect(),
                    tpi_crop2, touches = TRUE)
  z1 <- zonal(tpi_crop1, zones1, "mean", wide = FALSE, na.rm = TRUE) %>%
    mutate(range_id = !!id, 
           group = "true") %>%
    select(-layer)
  z2 <- zonal(tpi_crop2, zones2, "mean", wide = FALSE, na.rm = TRUE) %>%
    mutate(range_id = !!id, 
           group = "pseudo") %>%
    select(-layer)
  bind_rows(z1,z2)
}

musk_tpi <- musk_pseudohr %>%
  pull(range_id) %>%
  map(function(.x){tpi_func(.x, tpi_crop)}) %>%
  list_rbind()
saveRDS(musk_tpi, here("output/musk_tpi.rds"))

```

## Summer Model

```{r}
#| label: sum_pseudo_mod
#| dependson: "sum_pseudo"

musk_sum_lc <- hr_forage %>%
  left_join(musk_tpi) %>%
  left_join(musk_pseudohr %>%
              st_drop_geometry() %>%
              select(range_id, Id_Number, year_min, season)) %>%
  mutate(true_range = ifelse(group == "true",1,0)) %>%
  filter(season == "Summer") 
saveRDS(musk_sum_lc, here("output/musk_sum_lc.rds"))


musk_sum_lc %>%
  ggplot(aes(x = group, y = for_per)) +
  geom_boxplot() 
musk_sum_lc %>%
  ggplot(aes(x = group, y = value)) +
  geom_boxplot()  
musk_sum_lc %>%
  ungroup() %>%
  select(range_id, group, for_per, value) %>%
  pivot_wider(names_from = group, values_from = c(for_per, value)) %>%
  mutate(diff_for = for_per_pseudo - for_per_true,
         diff_val = value_pseudo - value_true) %>%
  select(diff_for, diff_val) %>%
  cor()
cor(musk_sum_lc$value, musk_sum_lc$for_per)


set.seed(5)
sum_pseudo_brm <- brms::brm(true_range ~ scale(for_per) +
                         (1|Id_Number), family = "bernoulli",
                       data = musk_sum_lc,
                 chains = 3,
                 cores = 3,
                 iter = 10000,
                 control = list(adapt_delta=0.9))

summary(sum_pseudo_brm)

```

It looks like, as with the buffer approach, home ranges are selected for their proportion of foraging area. We needed to use a Bayesian approach though, because the lme4 models were having a difficult time estimating the variance of the random effect, possibly a result of the small sample size.

## Winter Model

```{r}
#| label: wint_pseudo_mod
#| dependson: "wint_pseudo"

musk_wint_tpi <- hr_forage %>%
  left_join(musk_tpi) %>%
  left_join(musk_pseudohr %>%
              st_drop_geometry() %>%
              select(range_id, Id_Number, year_min, season)) %>%
  mutate(true_range = ifelse(group == "true",1,0)) %>%
  filter(season == "Winter") 
saveRDS(musk_wint_tpi, here("output/musk_wint_tpi.rds")) 

musk_wint_tpi %>%
  ggplot(aes(x = group, y = for_per)) +
  geom_boxplot() 
musk_wint_tpi %>%
  ggplot(aes(x = group, y = value)) +
  geom_boxplot() 
musk_wint_tpi %>%
  ungroup() %>%
  select(range_id, group, for_per, value) %>%
  pivot_wider(names_from = group, values_from = c(for_per, value)) %>%
  mutate(diff_for = for_per_pseudo - for_per_true,
         diff_val = value_pseudo - value_true) %>%
  select(diff_for, diff_val) %>%
  cor()

set.seed(5)
wint_pseudo_brm <- brms::brm(true_range ~ scale(value) + scale(for_per) +
                         (1|Id_Number), family = "bernoulli",
                       data = musk_wint_tpi,
                 chains = 3,
                 cores = 3,
                 iter = 10000,
                 control = list(adapt_delta =0.9))

summary(wint_pseudo_brm)
```

Home ranges are associated with higher topographic position indices indicating winter home ranges are more often elevated relative to their surroundings. Let's plot the winter home ranges on the TPI raster to better visualize it:

## Calving Model

```{r}
#| label: calv_pseudo_mod
#| dependson: "calv_pseudo"

musk_calv_tpi <- hr_forage %>%
  left_join(musk_tpi) %>%
  left_join(musk_pseudohr %>%
              st_drop_geometry() %>%
              select(range_id, Id_Number, year_min, season)) %>%
  mutate(true_range = ifelse(group == "true",1,0)) %>%
  filter(season == "Calving")
saveRDS(musk_calv_tpi, here("output/musk_calv_tpi.rds")) 


musk_calv_tpi %>%
  ggplot(aes(x = group, y = for_per)) +
  geom_boxplot() 
musk_calv_tpi %>%
  ggplot(aes(x = group, y = value)) +
  geom_boxplot() 
musk_calv_tpi %>%
  ungroup() %>%
  select(range_id, group, for_per, value) %>%
  pivot_wider(names_from = group, values_from = c(for_per, value)) %>%
  mutate(diff_for = for_per_pseudo - for_per_true,
         diff_val = value_pseudo - value_true) %>%
  select(diff_for, diff_val) %>%
  cor()


set.seed(5)

calv_pseudo_brm <- brms::brm(true_range ~ scale(value) +
                               scale(for_per) +
                         (1|Id_Number), family = "bernoulli",
                       data = musk_calv_tpi,
                 chains = 3,
                 cores = 3,
                 iter = 10000,
                 control = list(adapt_delta =0.9))

summary(calv_pseudo_brm)
```

```{r}
#| label: select_mod_coefs
#| echo: FALSE
#| eval: FALSE

sum_effects <- sum_pseudo_brm %>%
  tidybayes::spread_draws(`Intercept`, `b_scalefor_per`, 
                          `sd_Id_Number__Intercept`) %>%
  tidybayes::summarise_draws(~quantile(.x, probs = c(0.025,0.5,0.975))) %>%
  mutate(Parameter = c("Intercept", "Proportion \ngrassland/shrubland", 
                       "sd Muskox ID"),
         Effect = c("Fixed", "Fixed", "Random"),
         Season = "Summer")
wint_effects <- wint_pseudo_brm %>%
  tidybayes::spread_draws(`Intercept`, `b_scalevalue`, 
                          `sd_Id_Number__Intercept`) %>%
  tidybayes::summarise_draws(~quantile(.x, probs = c(0.025,0.5,0.975))) %>%
  mutate(Parameter = c("Intercept", "TPI", "sd Muskox ID"),
         Effect = c("Fixed", "Fixed", "Random"),
         Season = "Winter")
calv_effects <- calv_pseudo_brm %>%
  tidybayes::spread_draws(`Intercept`, `b_scalevalue`, 
                          `sd_Id_Number__Intercept`) %>%
  tidybayes::summarise_draws(~quantile(.x, probs = c(0.025,0.5,0.975))) %>%
  mutate(Parameter = c("Intercept", "TPI", "sd Muskox ID"),
         Effect = c("Fixed", "Fixed", "Random"),
         Season = "Calving")

select_mod_coefs <- bind_rows(sum_effects, wint_effects, calv_effects)

saveRDS(select_mod_coefs, here("output/select_mod_coefs.rds"))

```
