---
title: "Home Range"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
execute:
  echo: true
  warning: false
  error: false
---


```{r}
#| label: load-packages
#| include: false

library(tidyverse)
library(sf)
library(here)
```


In this document, we will estimate home range size for collared muskoxen and look to compare range overlap and size across years and seasons.

## Estimating Movement Model

Before we can estimate home ranges for the collared muskoxen, we need to determine an appropriate movement model. To do this, we will use variograms. Our data has been updated to conform to Movebank naming conventions so that we can use the **ctmm** package.

```{r}
#| label: load-data

library(ctmm)
musk_move <- read.csv(here("data/raw/muskox_data/musk_collar_filt_movebank.csv"))
musk_tel <- as.telemetry(musk_move)[c(-2,-4,-5)]

```

First we will plot empirical variograms for each collared muskoxen. Variograms are used to quantify spatial dependence between locations at different points in time. In general, as the time between locations increases, spatial dependence decreases. Variograms plot the semi-variance of distances between pairs of points separated by different time lags. At short time lags, these distances are very similar and the semi-variance is low. At large time lags, there is greater variability in the distances between points, so the semi-variance is high. Usually variograms will reach an asymptote in semi-variance that represents the time lag at which the animal is able to traverse their home range. For now we will leave out the muskoxen that had collar failures as they do not have enough data to estimate home ranges.

```{r}
#| label: musk_var
#| dependson: "load-data"
#| output: FALSE

musk_var <- lapply(musk_tel, variogram, CI="Gauss", fast = FALSE)
xlim <- c(0,5 %#% "day")
```

```{r, fig.height=4}
#| dependson: "musk_var"
map(musk_var, function(x) x %>% as_tibble() %>% mutate(id = x@info$identity)) %>% 
  list_rbind() %>%
  mutate(level = 0.95,
         ci.lower = SVF*qchisq((1-level)/2,DOF,lower.tail=TRUE)/DOF,
         ci.upper = SVF*qchisq((1-level)/2,DOF,lower.tail=FALSE)/DOF) %>%
  ggplot(aes(x = lag, y = SVF)) +
  geom_linerange(aes(ymin = ci.lower, ymax = ci.upper), colour = "grey") +
  geom_line() +
  facet_wrap(~id, scales = "free_y") +
  theme_bw()
```


Most of these look fine, however for two of the longer time series (7011 and 7012) the semi-variance appears to reach an asymptote by the first year, but starts increasing again part way through the second year. If this behaviour is common, home range estimates may be biased even after a year's worth of data. If  muskoxen truly are nomadic and lack site fidelty, kernel density methods may not be appropriate (Silva et al., 2022).

It is also clear there are some issues with collars 708 and 7010. Closer inspection of the data reveals that, every 7 fixes, there is a longer 24 hour delay until the next fix. Currently, the model uses the median sampling interval (8 hours) to estimate the variogram. The **variogram** function allows is to specify more than one time interval (in our case, 8 and 24 hours) to progressively coarsen the variogram. We can also specify an interval-weighted algorithm to further improve the appearance of the variogram.

```{r}
#| label: musk_var2
#| dependson: "musk_var"
#| output: FALSE

dt <- c(8, 24) %#% "hour"
musk_var[[2]] <- variogram(musk_tel[[2]], dt = dt, CI="Gauss", fast = FALSE)
musk_var[[3]] <- variogram(musk_tel[[3]], dt = dt, CI="Gauss", fast = FALSE)
```

```{r, fig.height=4}
#| dependson: "musk_var2"
map(musk_var, function(x) x %>% as_tibble() %>% mutate(id = x@info$identity)) %>% 
  list_rbind() %>%
  mutate(level = 0.95,
         ci.lower = SVF*qchisq((1-level)/2,DOF,lower.tail=TRUE)/DOF,
         ci.upper = SVF*qchisq((1-level)/2,DOF,lower.tail=FALSE)/DOF) %>%
  ggplot(aes(x = lag, y = SVF)) +
  geom_linerange(aes(ymin = ci.lower, ymax = ci.upper), colour = "grey") +
  geom_line() +
  facet_wrap(~id, scales = "free_y") +
  theme_bw()
```

These look better. Collars 7011 and 7012 do not appear to reach an asymptote in semi-variance as lag increases, suggesting that these individuals are not range resident. 7010 has a somewhat bell-shaped curve. This can be indicative of distinct winter and summer grounds. However, given that muskoxen appear to have limited movement in the winter and the ~1-year time series for 7010 starts and ends in winter, it seems more likely that the wintering grounds from one year to the next happened to be close together.

We can diagnose these issues further by fitting a variety of custom variogram functions to our data using the **ctmm.select** function. 

```{r, fig.height=4}
#| label: musk_var_mod
#| dependson: "musk_var2"

### fist create a best guess set of parameters for the model
musk_var_mod <- lapply(musk_var, variogram.fit, interactive = FALSE)
#fit <- mapply(function(x,y){ctmm.select(x,y,verbose = TRUE,cores = 3)},musk_tel,musk_var_mod)
#saveRDS(fit, here("output/musk_var_fit.rds"))
fit <- readRDS(here("output/musk_var_fit.rds"))
for (i in 1:length(musk_var)){print(musk_var[[i]]@info$identity);print(summary(fit[,i])); plot(musk_var[[i]], CTMM = fit[,i], col.CTMM=c("red","purple","blue", "green"),fraction=0.5,level=0.5);plot(musk_var[[i]], CTMM = fit[,i], col.CTMM=c("red","purple","blue", "green"),xlim = xlim,,level=0.5)}

```

These look okay, but they aren't capturing the short timescales well in all instances. This could be an issue with these individuals not being range resident, but it could also be related to telemetry error. To try to rectify this, we can attempt to fit models that account for potential error in the telemetry data. Normally, we would want to explicitly include measured error, but since we don't have those data, we can try to model it. This will partially account for instances where the muskox appeared to have moved between successive time stamps, but really didn't or instances where the muskox appeared to move between successive time stamps, but really didn't.

```{r}
#| label: musk_mod_err
#| dependson: "musk_var2"

# Had to save the parameters for variogram error here as I couldn't find
# another way to save them without using the interactive variogram fit function
#variogram.fit(musk_var[[1]], name = "var_error")
#saveRDS(var_error, here("data/processed/var_error.rds"))
var_error <- readRDS(here("data/processed/var_error.rds"))

musk_var_mod_err <- musk_var_mod
for (i in 1:length(musk_var_mod_err)){musk_var_mod_err[[i]]$error=var_error$error; musk_var_mod_err[[i]]$errors=var_error$errors}

#fit2 <- mapply(function(x,y){ctmm.select(x,y,verbose = TRUE,cores = 3)},musk_tel,musk_var_mod_err)
#saveRDS(fit2, here("output/musk_var_fit2.rds"))
fit2 <- readRDS(here("output/musk_var_fit2.rds"))

for (i in 1:length(musk_var)){print(musk_var[[i]]@info$identity);print(summary(fit2[,i])); plot(musk_var[[i]], CTMM = fit2[,i], col.CTMM=c("red","purple","blue", "green"),fraction=0.5,level=0.5);plot(musk_var[[i]], CTMM = fit2[,i], col.CTMM=c("red","purple","blue", "green"),xlim = xlim,,level=0.5)}

```


These look okay, but they aren't capturing the short timescales well in all instances. To illustrate this point, let's simulate new data based on the best fitted model for collar 706. 

```{r}
#| label: musk_sim
#| dependson: "musk_var_mod"

# set.seed(1)
# musk_sim <- simulate(fit[,1][[1]], t=musk_tel[[1]]$t)
# var_sim <- variogram(musk_sim)
# plot(var_sim, CTMM = fit[,1][[1]],fraction = 0.65, level = 0.5, col = "blue");title("Simulated 1")
# plot(musk_var[[1]], CTMM = fit[,1][[1]],fraction = 0.65, level = 0.5);title("Real")
# plot(var_sim, CTMM = fit[,1][[1]],xlim = xlim, level = 0.5, col = "blue");title("Simulated")
# plot(musk_var[[1]], CTMM = fit[,1][[1]],xlim = xlim, level = 0.5);title("Real")
# plot(musk_var[[1]],musk_var_mod[[1]],xlim = xlim, level = 0.5)
```

At large time scales, the modelled variogram does not appear to match up very well against the empirical variograms of the simulated and observed data. This is because the errors in the variograms (difference between modelled and empirical) are autocorrelated. Small perturbations are carried forward and can add up over time, but these are not necessarily a bad thing for fitting our model. 

In addition, as the time lag increase, so to does our uncertainty about the estimated semi-variance because larger time lags have fewer pairs of data points to estimate the semi-variance. We have the most certainty at short time lags because we have many pairs of data to estimate uncertainty. It appears as though the simulated variogram is better represented by our current model 

We can use kernel density estimates that account for these underlying movement models using the **akde** function. 

```{r, fig.height=4}
#| label: akde
#| dependson: "musk_var_mod"

akde <- akde(musk_tel[[5]],fit[,5][[1]])
EXT <- extent(akde,level=0.95)
plot(musk_tel[[5]],UD=akde,xlim=EXT$x,ylim=EXT$y)
```

```{r, fig.height=4}
#| label: musk_var_cv
#| dependson: "load-data"

musk_7011 <- musk_move %>%
  filter(individual.local.identifier == 7011) %>%
  mutate(datetime = as.POSIXct(timestamp))
musk_move_cv <- musk_7011 %>%
  bind_rows(musk_7011 %>% 
              filter(datetime < min(datetime)+(365/2)*24*60*60) %>%
              mutate(individual.local.identifier = 7011.1)) %>%
  bind_rows(musk_7011 %>% 
              filter(datetime < min(datetime)+(365)*24*60*60) %>%
              mutate(individual.local.identifier = 7011.2)) %>%
  bind_rows(musk_7011 %>% 
              filter(datetime < min(datetime)+(365*1.5)*24*60*60) %>%
              mutate(individual.local.identifier = 7011.3))
musk_tel_cv <- as.telemetry(musk_move_cv)
musk_var_cv <- lapply(musk_tel_cv, variogram, fast = FALSE)
for (i in 1:length(musk_var_cv)){plot(musk_var_cv[i], fraction = 0.65);title(musk_var_cv[[i]]@info$identity)}

musk_var_cv_mod <- lapply(musk_var_cv, variogram.fit, interactive = FALSE)
fit_cv <- mapply(function(x,y){ctmm.select(x,y,verbose = TRUE,cores = 3)},musk_tel_cv,musk_var_cv_mod)

akde <- list(akde(musk_tel_cv[[1]],fit_cv[,1][[1]]),
             akde(musk_tel_cv[[2]],fit_cv[,2][[1]]),
             akde(musk_tel_cv[[3]],fit_cv[,3][[1]]),
             akde(musk_tel_cv[[4]],fit_cv[,4][[1]]))
plot(musk_tel_cv[[1]],UD=akde[[2]])
plot(musk_tel_cv[[1]],UD=akde[[3]])
plot(musk_tel_cv[[1]],UD=akde[[4]])
plot(musk_tel_cv[[1]],UD=akde[[1]])

```